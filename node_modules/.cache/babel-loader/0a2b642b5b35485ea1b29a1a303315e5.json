{"ast":null,"code":"import _includes from \"lodash/includes\";\nimport _isEqual from \"lodash/isEqual\";\nimport _isEmpty from \"lodash/isEmpty\";\nimport _orderBy from \"lodash/orderBy\";\nimport _property from \"lodash/property\";\nimport _isPlainObject from \"lodash/isPlainObject\";\nimport _isFunction from \"lodash/isFunction\";\nimport _last from \"lodash/last\";\nimport _range from \"lodash/range\";\nimport _uniq from \"lodash/uniq\";\nimport _assign from \"lodash/assign\";\n\nfunction _toConsumableArray(arr) {\n  return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _nonIterableSpread();\n}\n\nfunction _nonIterableSpread() {\n  throw new TypeError(\"Invalid attempt to spread non-iterable instance\");\n}\n\nfunction _iterableToArray(iter) {\n  if (Symbol.iterator in Object(iter) || Object.prototype.toString.call(iter) === \"[object Arguments]\") return Array.from(iter);\n}\n\nfunction _arrayWithoutHoles(arr) {\n  if (Array.isArray(arr)) {\n    for (var i = 0, arr2 = new Array(arr.length); i < arr.length; i++) {\n      arr2[i] = arr[i];\n    }\n\n    return arr2;\n  }\n}\n/* eslint-disable func-style */\n\n/* eslint-disable no-use-before-define */\n\n\nimport React from \"react\";\nimport Helpers from \"./helpers\";\nimport Collection from \"./collection\";\nimport Scale from \"./scale\";\nimport Immutable from \"./immutable\"; // Private Functions\n\nfunction parseDatum(datum) {\n  var immutableDatumWhitelist = {\n    errorX: true,\n    errorY: true\n  };\n  return Immutable.isImmutable(datum) ? Immutable.shallowToJS(datum, immutableDatumWhitelist) : datum;\n}\n\nfunction getLength(data) {\n  return Immutable.isIterable(data) ? data.size : data.length;\n} // Returns generated data for a given axis based on domain and sample from props\n\n\nfunction generateDataArray(props, axis) {\n  var propsDomain = _isPlainObject(props.domain) ? props.domain[axis] : props.domain;\n  var domain = propsDomain || Scale.getBaseScale(props, axis).domain();\n  var samples = props.samples || 1;\n  var domainMax = Math.max.apply(Math, _toConsumableArray(domain));\n  var domainMin = Math.min.apply(Math, _toConsumableArray(domain));\n  var step = (domainMax - domainMin) / samples;\n\n  var values = _range(domainMin, domainMax, step);\n\n  return _last(values) === domainMax ? values : values.concat(domainMax);\n} // Returns sorted data. If no sort keys are provided, data is returned unaltered.\n\n\nfunction sortData(dataset, sortKey) {\n  var sortOrder = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : \"ascending\";\n\n  if (!sortKey) {\n    return dataset;\n  } // Ensures previous VictoryLine api for sortKey prop stays consistent\n\n\n  if (sortKey === \"x\" || sortKey === \"y\") {\n    sortKey = \"_\".concat(sortKey);\n  }\n\n  var order = sortOrder === \"ascending\" ? \"asc\" : \"desc\";\n  return _orderBy(dataset, sortKey, order);\n} // This method will remove data points that break certain scales. (log scale only)\n\n\nfunction cleanData(dataset, props) {\n  var smallNumber = 1 / Number.MAX_SAFE_INTEGER;\n  var scaleType = {\n    x: Scale.getScaleType(props, \"x\"),\n    y: Scale.getScaleType(props, \"y\")\n  };\n\n  if (scaleType.x !== \"log\" && scaleType.y !== \"log\") {\n    return dataset;\n  }\n\n  var rules = function (datum, axis) {\n    return scaleType[axis] === \"log\" ? datum[\"_\".concat(axis)] !== 0 : true;\n  };\n\n  var sanitize = function (datum) {\n    var _x = rules(datum, \"x\") ? datum._x : smallNumber;\n\n    var _y = rules(datum, \"y\") ? datum._y : smallNumber;\n\n    var _y0 = rules(datum, \"y0\") ? datum._y0 : smallNumber;\n\n    return _assign({}, datum, {\n      _x: _x,\n      _y: _y,\n      _y0: _y0\n    });\n  };\n\n  return dataset.map(function (datum) {\n    if (rules(datum, \"x\") && rules(datum, \"y\") && rules(datum, \"y0\")) {\n      return datum;\n    }\n\n    return sanitize(datum);\n  });\n} // Returns a data accessor given an eventKey prop\n\n\nfunction getEventKey(key) {\n  // creates a data accessor function\n  // given a property key, path, array index, or null for identity.\n  if (_isFunction(key)) {\n    return key;\n  } else if (key === null || key === undefined) {\n    return function () {\n      return undefined;\n    };\n  } // otherwise, assume it is an array index, property key or path (_.property handles all three)\n\n\n  return _property(key);\n} // Returns data with an eventKey prop added to each datum\n\n\nfunction addEventKeys(props, data) {\n  var hasEventKeyAccessor = !!props.eventKey;\n  var eventKeyAccessor = getEventKey(props.eventKey);\n  return data.map(function (datum, index) {\n    if (datum.eventKey !== undefined) {\n      return datum;\n    } else if (hasEventKeyAccessor) {\n      var eventKey = eventKeyAccessor(datum, index);\n      return eventKey !== undefined ? _assign({\n        eventKey: eventKey\n      }, datum) : datum;\n    } else {\n      return datum;\n    }\n  });\n} // Exported Functions\n\n/**\n * Returns an object mapping string data to numeric data\n * @param {Object} props: the props object\n * @param {String} axis: the current axis\n * @returns {Object} an object mapping string data to numeric data\n */\n\n\nfunction createStringMap(props, axis) {\n  var stringsFromAxes = getStringsFromAxes(props, axis);\n  var stringsFromCategories = getStringsFromCategories(props, axis);\n  var stringsFromData = getStringsFromData(props, axis);\n\n  var allStrings = _uniq(_toConsumableArray(stringsFromAxes).concat(_toConsumableArray(stringsFromCategories), _toConsumableArray(stringsFromData)));\n\n  return allStrings.length === 0 ? null : allStrings.reduce(function (memo, string, index) {\n    memo[string] = index + 1;\n    return memo;\n  }, {});\n}\n/**\n * Reduces the size of a data array, such that it is <= maxPoints.\n * @param {Array} data: an array of data; must be sorted\n * @param {Number} maxPoints: maximum number of data points to return\n * @param {Number} startingIndex: the index of the data[0] *in the entire dataset*; this function\n                   assumes `data` param is a subset of larger dataset that has been zoommed\n  * @returns {Array} an array of data, a subset of data param\n  */\n\n\nfunction downsample(data, maxPoints) {\n  var startingIndex = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0; // ensures that the downampling of data while zooming looks good.\n\n  var dataLength = getLength(data);\n\n  if (dataLength > maxPoints) {\n    // limit k to powers of 2, e.g. 64, 128, 256\n    // so that the same points will be chosen reliably, reducing flicker on zoom\n    var k = Math.pow(2, Math.ceil(Math.log2(dataLength / maxPoints)));\n    return data.filter( // ensure modulo is always calculated from same reference: i + startingIndex\n    function (d, i) {\n      return (i + startingIndex) % k === 0;\n    });\n  }\n\n  return data;\n}\n/**\n * Returns formatted data. Data accessors are applied, and string values are replaced.\n * @param {Array} dataset: the original domain\n * @param {Object} props: the props object\n * @param {Array} expectedKeys: an array of expected data keys\n * @returns {Array} the formatted data\n */\n\n\nfunction formatData(dataset, props, expectedKeys) {\n  var isArrayOrIterable = Array.isArray(dataset) || Immutable.isIterable(dataset);\n\n  if (!isArrayOrIterable || getLength(dataset) < 1) {\n    return [];\n  }\n\n  var defaultKeys = [\"x\", \"y\", \"y0\"];\n  expectedKeys = Array.isArray(expectedKeys) ? expectedKeys : defaultKeys;\n\n  var createAccessor = function (name) {\n    return Helpers.createAccessor(props[name] !== undefined ? props[name] : name);\n  };\n\n  var accessor = expectedKeys.reduce(function (memo, type) {\n    memo[type] = createAccessor(type);\n    return memo;\n  }, {});\n  var preformattedData = _isEqual(expectedKeys, defaultKeys) && props.x === \"_x\" && props.y === \"_y\" && props.y0 === \"_y0\";\n  var stringMap;\n\n  if (preformattedData === false) {\n    // stringMap is not required if the data is preformatted\n    stringMap = {\n      x: expectedKeys.indexOf(\"x\") !== -1 ? createStringMap(props, \"x\") : undefined,\n      y: expectedKeys.indexOf(\"y\") !== -1 ? createStringMap(props, \"y\") : undefined,\n      y0: expectedKeys.indexOf(\"y0\") !== -1 ? createStringMap(props, \"y\") : undefined\n    };\n  }\n\n  var data = preformattedData ? dataset : dataset.reduce(function (dataArr, datum, index) {\n    // eslint-disable-line complexity\n    datum = parseDatum(datum);\n    var fallbackValues = {\n      x: index,\n      y: datum\n    };\n    var processedValues = expectedKeys.reduce(function (memo, type) {\n      var processedValue = accessor[type](datum);\n      var value = processedValue !== undefined ? processedValue : fallbackValues[type];\n\n      if (value !== undefined) {\n        if (typeof value === \"string\" && stringMap[type]) {\n          memo[\"\".concat(type, \"Name\")] = value;\n          memo[\"_\".concat(type)] = stringMap[type][value];\n        } else {\n          memo[\"_\".concat(type)] = value;\n        }\n      }\n\n      return memo;\n    }, {});\n\n    var formattedDatum = _assign({}, processedValues, datum);\n\n    if (!_isEmpty(formattedDatum)) {\n      dataArr.push(formattedDatum);\n    }\n\n    return dataArr;\n  }, []);\n  var sortedData = sortData(data, props.sortKey, props.sortOrder);\n  var cleanedData = cleanData(sortedData, props);\n  return addEventKeys(props, cleanedData);\n}\n/**\n * Returns generated x and y data based on domain and sample from props\n * @param {Object} props: the props object\n * @returns {Array} an array of data\n */\n\n\nfunction generateData(props) {\n  var xValues = generateDataArray(props, \"x\");\n  var yValues = generateDataArray(props, \"y\");\n  var values = xValues.map(function (x, i) {\n    return {\n      x: x,\n      y: yValues[i]\n    };\n  });\n  return values;\n}\n/**\n * Returns an array of categories for a given axis\n * @param {Object} props: the props object\n * @param {String} axis: the current axis\n * @returns {Array} an array of categories\n */\n\n\nfunction getCategories(props, axis) {\n  return props.categories && !Array.isArray(props.categories) ? props.categories[axis] : props.categories;\n}\n/**\n * Returns an array of formatted data\n * @param {Object} props: the props object\n * @returns {Array} an array of data\n */\n\n\nfunction getData(props) {\n  return props.data ? formatData(props.data, props) : formatData(generateData(props), props);\n}\n/**\n * Returns an array of strings from axis tickValues for a given axis\n * @param {Object} props: the props object\n * @param {String} axis: the current axis\n * @returns {Array} an array of strings\n */\n\n\nfunction getStringsFromAxes(props, axis) {\n  var tickValues = props.tickValues,\n      tickFormat = props.tickFormat;\n  var tickValueArray;\n\n  if (!tickValues || !Array.isArray(tickValues) && !tickValues[axis]) {\n    tickValueArray = tickFormat && Array.isArray(tickFormat) ? tickFormat : [];\n  } else {\n    tickValueArray = tickValues[axis] || tickValues;\n  }\n\n  return tickValueArray.filter(function (val) {\n    return typeof val === \"string\";\n  });\n}\n/**\n * Returns an array of strings from categories for a given axis\n * @param {Object} props: the props object\n * @param {String} axis: the current axis\n * @returns {Array} an array of strings\n */\n\n\nfunction getStringsFromCategories(props, axis) {\n  if (!props.categories) {\n    return [];\n  }\n\n  var categories = getCategories(props, axis);\n  var categoryStrings = categories && categories.filter(function (val) {\n    return typeof val === \"string\";\n  });\n  return categoryStrings ? Collection.removeUndefined(categoryStrings) : [];\n}\n/**\n * Returns an array of strings from data\n * @param {Object} props: the props object\n * @param {String} axis: the current axis\n * @returns {Array} an array of strings\n */\n\n\nfunction getStringsFromData(props, axis) {\n  var isArrayOrIterable = Array.isArray(props.data) || Immutable.isIterable(props.data);\n\n  if (!isArrayOrIterable) {\n    return [];\n  }\n\n  var key = props[axis] === undefined ? axis : props[axis];\n  var accessor = Helpers.createAccessor(key); // support immutable data\n\n  var data = props.data.reduce(function (memo, d) {\n    memo.push(parseDatum(d));\n    return memo;\n  }, []);\n  var sortedData = sortData(data, props.sortKey, props.sortOrder);\n  var dataStrings = sortedData.reduce(function (dataArr, datum) {\n    datum = parseDatum(datum);\n    dataArr.push(accessor(datum));\n    return dataArr;\n  }, []).filter(function (datum) {\n    return typeof datum === \"string\";\n  }); // return a unique set of strings\n\n  return dataStrings.reduce(function (prev, curr) {\n    if (curr !== undefined && curr !== null && prev.indexOf(curr) === -1) {\n      prev.push(curr);\n    }\n\n    return prev;\n  }, []);\n}\n/**\n * Checks whether a given component can be used to calculate date\n * @param {Component} component: a React component instance\n * @returns {Boolean} Returns true if the given component has a role included in the whitelist\n */\n\n\nfunction isDataComponent(component) {\n  var getRole = function (child) {\n    return child && child.type ? child.type.role : \"\";\n  };\n\n  var role = getRole(component);\n\n  if (role === \"portal\") {\n    var children = React.Children.toArray(component.props.children);\n    role = children.length ? getRole(children[0]) : \"\";\n  }\n\n  var whitelist = [\"area\", \"bar\", \"boxplot\", \"candlestick\", \"errorbar\", \"group\", \"line\", \"pie\", \"scatter\", \"stack\", \"voronoi\"];\n  return _includes(whitelist, role);\n}\n\nexport default {\n  createStringMap: createStringMap,\n  downsample: downsample,\n  formatData: formatData,\n  generateData: generateData,\n  getCategories: getCategories,\n  getData: getData,\n  getStringsFromAxes: getStringsFromAxes,\n  getStringsFromCategories: getStringsFromCategories,\n  getStringsFromData: getStringsFromData,\n  isDataComponent: isDataComponent\n};","map":{"version":3,"sources":["/Users/abdurauf/Desktop/diploma/restaurant-management-system/plov/node_modules/victory-core/es/victory-util/data.js"],"names":["_includes","_isEqual","_isEmpty","_orderBy","_property","_isPlainObject","_isFunction","_last","_range","_uniq","_assign","_toConsumableArray","arr","_arrayWithoutHoles","_iterableToArray","_nonIterableSpread","TypeError","iter","Symbol","iterator","Object","prototype","toString","call","Array","from","isArray","i","arr2","length","React","Helpers","Collection","Scale","Immutable","parseDatum","datum","immutableDatumWhitelist","errorX","errorY","isImmutable","shallowToJS","getLength","data","isIterable","size","generateDataArray","props","axis","propsDomain","domain","getBaseScale","samples","domainMax","Math","max","apply","domainMin","min","step","values","concat","sortData","dataset","sortKey","sortOrder","arguments","undefined","order","cleanData","smallNumber","Number","MAX_SAFE_INTEGER","scaleType","x","getScaleType","y","rules","sanitize","_x","_y","_y0","map","getEventKey","key","addEventKeys","hasEventKeyAccessor","eventKey","eventKeyAccessor","index","createStringMap","stringsFromAxes","getStringsFromAxes","stringsFromCategories","getStringsFromCategories","stringsFromData","getStringsFromData","allStrings","reduce","memo","string","downsample","maxPoints","startingIndex","dataLength","k","pow","ceil","log2","filter","d","formatData","expectedKeys","isArrayOrIterable","defaultKeys","createAccessor","name","accessor","type","preformattedData","y0","stringMap","indexOf","dataArr","fallbackValues","processedValues","processedValue","value","formattedDatum","push","sortedData","cleanedData","generateData","xValues","yValues","getCategories","categories","getData","tickValues","tickFormat","tickValueArray","val","categoryStrings","removeUndefined","dataStrings","prev","curr","isDataComponent","component","getRole","child","role","children","Children","toArray","whitelist"],"mappings":"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","sourcesContent":["import _includes from \"lodash/includes\";\nimport _isEqual from \"lodash/isEqual\";\nimport _isEmpty from \"lodash/isEmpty\";\nimport _orderBy from \"lodash/orderBy\";\nimport _property from \"lodash/property\";\nimport _isPlainObject from \"lodash/isPlainObject\";\nimport _isFunction from \"lodash/isFunction\";\nimport _last from \"lodash/last\";\nimport _range from \"lodash/range\";\nimport _uniq from \"lodash/uniq\";\nimport _assign from \"lodash/assign\";\n\nfunction _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _nonIterableSpread(); }\n\nfunction _nonIterableSpread() { throw new TypeError(\"Invalid attempt to spread non-iterable instance\"); }\n\nfunction _iterableToArray(iter) { if (Symbol.iterator in Object(iter) || Object.prototype.toString.call(iter) === \"[object Arguments]\") return Array.from(iter); }\n\nfunction _arrayWithoutHoles(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = new Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } }\n\n/* eslint-disable func-style */\n\n/* eslint-disable no-use-before-define */\nimport React from \"react\";\nimport Helpers from \"./helpers\";\nimport Collection from \"./collection\";\nimport Scale from \"./scale\";\nimport Immutable from \"./immutable\"; // Private Functions\n\nfunction parseDatum(datum) {\n  var immutableDatumWhitelist = {\n    errorX: true,\n    errorY: true\n  };\n  return Immutable.isImmutable(datum) ? Immutable.shallowToJS(datum, immutableDatumWhitelist) : datum;\n}\n\nfunction getLength(data) {\n  return Immutable.isIterable(data) ? data.size : data.length;\n} // Returns generated data for a given axis based on domain and sample from props\n\n\nfunction generateDataArray(props, axis) {\n  var propsDomain = _isPlainObject(props.domain) ? props.domain[axis] : props.domain;\n  var domain = propsDomain || Scale.getBaseScale(props, axis).domain();\n  var samples = props.samples || 1;\n  var domainMax = Math.max.apply(Math, _toConsumableArray(domain));\n  var domainMin = Math.min.apply(Math, _toConsumableArray(domain));\n  var step = (domainMax - domainMin) / samples;\n\n  var values = _range(domainMin, domainMax, step);\n\n  return _last(values) === domainMax ? values : values.concat(domainMax);\n} // Returns sorted data. If no sort keys are provided, data is returned unaltered.\n\n\nfunction sortData(dataset, sortKey) {\n  var sortOrder = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : \"ascending\";\n\n  if (!sortKey) {\n    return dataset;\n  } // Ensures previous VictoryLine api for sortKey prop stays consistent\n\n\n  if (sortKey === \"x\" || sortKey === \"y\") {\n    sortKey = \"_\".concat(sortKey);\n  }\n\n  var order = sortOrder === \"ascending\" ? \"asc\" : \"desc\";\n  return _orderBy(dataset, sortKey, order);\n} // This method will remove data points that break certain scales. (log scale only)\n\n\nfunction cleanData(dataset, props) {\n  var smallNumber = 1 / Number.MAX_SAFE_INTEGER;\n  var scaleType = {\n    x: Scale.getScaleType(props, \"x\"),\n    y: Scale.getScaleType(props, \"y\")\n  };\n\n  if (scaleType.x !== \"log\" && scaleType.y !== \"log\") {\n    return dataset;\n  }\n\n  var rules = function (datum, axis) {\n    return scaleType[axis] === \"log\" ? datum[\"_\".concat(axis)] !== 0 : true;\n  };\n\n  var sanitize = function (datum) {\n    var _x = rules(datum, \"x\") ? datum._x : smallNumber;\n\n    var _y = rules(datum, \"y\") ? datum._y : smallNumber;\n\n    var _y0 = rules(datum, \"y0\") ? datum._y0 : smallNumber;\n\n    return _assign({}, datum, {\n      _x: _x,\n      _y: _y,\n      _y0: _y0\n    });\n  };\n\n  return dataset.map(function (datum) {\n    if (rules(datum, \"x\") && rules(datum, \"y\") && rules(datum, \"y0\")) {\n      return datum;\n    }\n\n    return sanitize(datum);\n  });\n} // Returns a data accessor given an eventKey prop\n\n\nfunction getEventKey(key) {\n  // creates a data accessor function\n  // given a property key, path, array index, or null for identity.\n  if (_isFunction(key)) {\n    return key;\n  } else if (key === null || key === undefined) {\n    return function () {\n      return undefined;\n    };\n  } // otherwise, assume it is an array index, property key or path (_.property handles all three)\n\n\n  return _property(key);\n} // Returns data with an eventKey prop added to each datum\n\n\nfunction addEventKeys(props, data) {\n  var hasEventKeyAccessor = !!props.eventKey;\n  var eventKeyAccessor = getEventKey(props.eventKey);\n  return data.map(function (datum, index) {\n    if (datum.eventKey !== undefined) {\n      return datum;\n    } else if (hasEventKeyAccessor) {\n      var eventKey = eventKeyAccessor(datum, index);\n      return eventKey !== undefined ? _assign({\n        eventKey: eventKey\n      }, datum) : datum;\n    } else {\n      return datum;\n    }\n  });\n} // Exported Functions\n\n/**\n * Returns an object mapping string data to numeric data\n * @param {Object} props: the props object\n * @param {String} axis: the current axis\n * @returns {Object} an object mapping string data to numeric data\n */\n\n\nfunction createStringMap(props, axis) {\n  var stringsFromAxes = getStringsFromAxes(props, axis);\n  var stringsFromCategories = getStringsFromCategories(props, axis);\n  var stringsFromData = getStringsFromData(props, axis);\n\n  var allStrings = _uniq(_toConsumableArray(stringsFromAxes).concat(_toConsumableArray(stringsFromCategories), _toConsumableArray(stringsFromData)));\n\n  return allStrings.length === 0 ? null : allStrings.reduce(function (memo, string, index) {\n    memo[string] = index + 1;\n    return memo;\n  }, {});\n}\n/**\n * Reduces the size of a data array, such that it is <= maxPoints.\n * @param {Array} data: an array of data; must be sorted\n * @param {Number} maxPoints: maximum number of data points to return\n * @param {Number} startingIndex: the index of the data[0] *in the entire dataset*; this function\n                   assumes `data` param is a subset of larger dataset that has been zoommed\n  * @returns {Array} an array of data, a subset of data param\n  */\n\n\nfunction downsample(data, maxPoints) {\n  var startingIndex = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;\n  // ensures that the downampling of data while zooming looks good.\n  var dataLength = getLength(data);\n\n  if (dataLength > maxPoints) {\n    // limit k to powers of 2, e.g. 64, 128, 256\n    // so that the same points will be chosen reliably, reducing flicker on zoom\n    var k = Math.pow(2, Math.ceil(Math.log2(dataLength / maxPoints)));\n    return data.filter( // ensure modulo is always calculated from same reference: i + startingIndex\n    function (d, i) {\n      return (i + startingIndex) % k === 0;\n    });\n  }\n\n  return data;\n}\n/**\n * Returns formatted data. Data accessors are applied, and string values are replaced.\n * @param {Array} dataset: the original domain\n * @param {Object} props: the props object\n * @param {Array} expectedKeys: an array of expected data keys\n * @returns {Array} the formatted data\n */\n\n\nfunction formatData(dataset, props, expectedKeys) {\n  var isArrayOrIterable = Array.isArray(dataset) || Immutable.isIterable(dataset);\n\n  if (!isArrayOrIterable || getLength(dataset) < 1) {\n    return [];\n  }\n\n  var defaultKeys = [\"x\", \"y\", \"y0\"];\n  expectedKeys = Array.isArray(expectedKeys) ? expectedKeys : defaultKeys;\n\n  var createAccessor = function (name) {\n    return Helpers.createAccessor(props[name] !== undefined ? props[name] : name);\n  };\n\n  var accessor = expectedKeys.reduce(function (memo, type) {\n    memo[type] = createAccessor(type);\n    return memo;\n  }, {});\n  var preformattedData = _isEqual(expectedKeys, defaultKeys) && props.x === \"_x\" && props.y === \"_y\" && props.y0 === \"_y0\";\n  var stringMap;\n\n  if (preformattedData === false) {\n    // stringMap is not required if the data is preformatted\n    stringMap = {\n      x: expectedKeys.indexOf(\"x\") !== -1 ? createStringMap(props, \"x\") : undefined,\n      y: expectedKeys.indexOf(\"y\") !== -1 ? createStringMap(props, \"y\") : undefined,\n      y0: expectedKeys.indexOf(\"y0\") !== -1 ? createStringMap(props, \"y\") : undefined\n    };\n  }\n\n  var data = preformattedData ? dataset : dataset.reduce(function (dataArr, datum, index) {\n    // eslint-disable-line complexity\n    datum = parseDatum(datum);\n    var fallbackValues = {\n      x: index,\n      y: datum\n    };\n    var processedValues = expectedKeys.reduce(function (memo, type) {\n      var processedValue = accessor[type](datum);\n      var value = processedValue !== undefined ? processedValue : fallbackValues[type];\n\n      if (value !== undefined) {\n        if (typeof value === \"string\" && stringMap[type]) {\n          memo[\"\".concat(type, \"Name\")] = value;\n          memo[\"_\".concat(type)] = stringMap[type][value];\n        } else {\n          memo[\"_\".concat(type)] = value;\n        }\n      }\n\n      return memo;\n    }, {});\n\n    var formattedDatum = _assign({}, processedValues, datum);\n\n    if (!_isEmpty(formattedDatum)) {\n      dataArr.push(formattedDatum);\n    }\n\n    return dataArr;\n  }, []);\n  var sortedData = sortData(data, props.sortKey, props.sortOrder);\n  var cleanedData = cleanData(sortedData, props);\n  return addEventKeys(props, cleanedData);\n}\n/**\n * Returns generated x and y data based on domain and sample from props\n * @param {Object} props: the props object\n * @returns {Array} an array of data\n */\n\n\nfunction generateData(props) {\n  var xValues = generateDataArray(props, \"x\");\n  var yValues = generateDataArray(props, \"y\");\n  var values = xValues.map(function (x, i) {\n    return {\n      x: x,\n      y: yValues[i]\n    };\n  });\n  return values;\n}\n/**\n * Returns an array of categories for a given axis\n * @param {Object} props: the props object\n * @param {String} axis: the current axis\n * @returns {Array} an array of categories\n */\n\n\nfunction getCategories(props, axis) {\n  return props.categories && !Array.isArray(props.categories) ? props.categories[axis] : props.categories;\n}\n/**\n * Returns an array of formatted data\n * @param {Object} props: the props object\n * @returns {Array} an array of data\n */\n\n\nfunction getData(props) {\n  return props.data ? formatData(props.data, props) : formatData(generateData(props), props);\n}\n/**\n * Returns an array of strings from axis tickValues for a given axis\n * @param {Object} props: the props object\n * @param {String} axis: the current axis\n * @returns {Array} an array of strings\n */\n\n\nfunction getStringsFromAxes(props, axis) {\n  var tickValues = props.tickValues,\n      tickFormat = props.tickFormat;\n  var tickValueArray;\n\n  if (!tickValues || !Array.isArray(tickValues) && !tickValues[axis]) {\n    tickValueArray = tickFormat && Array.isArray(tickFormat) ? tickFormat : [];\n  } else {\n    tickValueArray = tickValues[axis] || tickValues;\n  }\n\n  return tickValueArray.filter(function (val) {\n    return typeof val === \"string\";\n  });\n}\n/**\n * Returns an array of strings from categories for a given axis\n * @param {Object} props: the props object\n * @param {String} axis: the current axis\n * @returns {Array} an array of strings\n */\n\n\nfunction getStringsFromCategories(props, axis) {\n  if (!props.categories) {\n    return [];\n  }\n\n  var categories = getCategories(props, axis);\n  var categoryStrings = categories && categories.filter(function (val) {\n    return typeof val === \"string\";\n  });\n  return categoryStrings ? Collection.removeUndefined(categoryStrings) : [];\n}\n/**\n * Returns an array of strings from data\n * @param {Object} props: the props object\n * @param {String} axis: the current axis\n * @returns {Array} an array of strings\n */\n\n\nfunction getStringsFromData(props, axis) {\n  var isArrayOrIterable = Array.isArray(props.data) || Immutable.isIterable(props.data);\n\n  if (!isArrayOrIterable) {\n    return [];\n  }\n\n  var key = props[axis] === undefined ? axis : props[axis];\n  var accessor = Helpers.createAccessor(key); // support immutable data\n\n  var data = props.data.reduce(function (memo, d) {\n    memo.push(parseDatum(d));\n    return memo;\n  }, []);\n  var sortedData = sortData(data, props.sortKey, props.sortOrder);\n  var dataStrings = sortedData.reduce(function (dataArr, datum) {\n    datum = parseDatum(datum);\n    dataArr.push(accessor(datum));\n    return dataArr;\n  }, []).filter(function (datum) {\n    return typeof datum === \"string\";\n  }); // return a unique set of strings\n\n  return dataStrings.reduce(function (prev, curr) {\n    if (curr !== undefined && curr !== null && prev.indexOf(curr) === -1) {\n      prev.push(curr);\n    }\n\n    return prev;\n  }, []);\n}\n/**\n * Checks whether a given component can be used to calculate date\n * @param {Component} component: a React component instance\n * @returns {Boolean} Returns true if the given component has a role included in the whitelist\n */\n\n\nfunction isDataComponent(component) {\n  var getRole = function (child) {\n    return child && child.type ? child.type.role : \"\";\n  };\n\n  var role = getRole(component);\n\n  if (role === \"portal\") {\n    var children = React.Children.toArray(component.props.children);\n    role = children.length ? getRole(children[0]) : \"\";\n  }\n\n  var whitelist = [\"area\", \"bar\", \"boxplot\", \"candlestick\", \"errorbar\", \"group\", \"line\", \"pie\", \"scatter\", \"stack\", \"voronoi\"];\n  return _includes(whitelist, role);\n}\n\nexport default {\n  createStringMap: createStringMap,\n  downsample: downsample,\n  formatData: formatData,\n  generateData: generateData,\n  getCategories: getCategories,\n  getData: getData,\n  getStringsFromAxes: getStringsFromAxes,\n  getStringsFromCategories: getStringsFromCategories,\n  getStringsFromData: getStringsFromData,\n  isDataComponent: isDataComponent\n};"]},"metadata":{},"sourceType":"module"}