{"ast":null,"code":"import _includes from \"lodash/includes\";\nimport _isFunction from \"lodash/isFunction\";\nimport _sortedUniq from \"lodash/sortedUniq\";\nimport _isPlainObject from \"lodash/isPlainObject\";\nimport _flatten from \"lodash/flatten\";\n\nfunction _toConsumableArray(arr) {\n  return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _nonIterableSpread();\n}\n\nfunction _nonIterableSpread() {\n  throw new TypeError(\"Invalid attempt to spread non-iterable instance\");\n}\n\nfunction _iterableToArray(iter) {\n  if (Symbol.iterator in Object(iter) || Object.prototype.toString.call(iter) === \"[object Arguments]\") return Array.from(iter);\n}\n\nfunction _arrayWithoutHoles(arr) {\n  if (Array.isArray(arr)) {\n    for (var i = 0, arr2 = new Array(arr.length); i < arr.length; i++) {\n      arr2[i] = arr[i];\n    }\n\n    return arr2;\n  }\n}\n/* eslint-disable func-style */\n\n/* eslint-disable no-use-before-define */\n\n\nimport React from \"react\";\nimport Data from \"./data\";\nimport Scale from \"./scale\";\nimport Helpers from \"./helpers\";\nimport Collection from \"./collection\"; // Private Methods\n\nfunction cleanDomain(domain, props, axis) {\n  var scaleType = Scale.getScaleType(props, axis);\n\n  if (scaleType !== \"log\") {\n    return domain;\n  }\n\n  var rules = function rules(dom) {\n    var almostZero = dom[0] < 0 || dom[1] < 0 ? -1 / Number.MAX_SAFE_INTEGER : 1 / Number.MAX_SAFE_INTEGER;\n    var domainOne = dom[0] === 0 ? almostZero : dom[0];\n    var domainTwo = dom[1] === 0 ? almostZero : dom[1];\n    return [domainOne, domainTwo];\n  };\n\n  return rules(domain);\n}\n\nfunction getDomainPadding(props, axis) {\n  var formatPadding = function formatPadding(padding) {\n    return Array.isArray(padding) ? {\n      left: padding[0],\n      right: padding[1]\n    } : {\n      left: padding,\n      right: padding\n    };\n  };\n\n  return _isPlainObject(props.domainPadding) ? formatPadding(props.domainPadding[axis]) : formatPadding(props.domainPadding);\n}\n\nfunction getFlatData(dataset, axis) {\n  return _flatten(dataset).map(function (datum) {\n    return datum[\"_\".concat(axis)] && datum[\"_\".concat(axis)][1] !== undefined ? datum[\"_\".concat(axis)][1] : datum[\"_\".concat(axis)];\n  });\n}\n\nfunction getExtremeFromData(dataset, axis) {\n  var type = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : \"min\";\n\n  var getExtreme = function getExtreme(arr) {\n    return type === \"max\" ? Math.max.apply(Math, _toConsumableArray(arr)) : Math.min.apply(Math, _toConsumableArray(arr));\n  };\n\n  var initialValue = type === \"max\" ? -Infinity : Infinity;\n  var containsDate = false;\n\n  var result = _flatten(dataset).reduce(function (memo, datum) {\n    var current0 = datum[\"_\".concat(axis, \"0\")] !== undefined ? datum[\"_\".concat(axis, \"0\")] : datum[\"_\".concat(axis)];\n    var current1 = datum[\"_\".concat(axis, \"1\")] !== undefined ? datum[\"_\".concat(axis, \"1\")] : datum[\"_\".concat(axis)];\n    var current = getExtreme([current0, current1]);\n    containsDate = containsDate || current0 instanceof Date || current1 instanceof Date;\n    return getExtreme([memo, current]);\n  }, initialValue);\n\n  return containsDate ? new Date(result) : result;\n} //eslint-disable-next-line max-statements\n\n\nfunction padDomain(domain, props, axis) {\n  if (!props.domainPadding) {\n    return domain;\n  }\n\n  var minDomain = getMinFromProps(props, axis);\n  var maxDomain = getMaxFromProps(props, axis);\n  var padding = getDomainPadding(props, axis);\n\n  if (!padding.left && !padding.right) {\n    return domain;\n  }\n\n  var min = Collection.getMinValue(domain);\n  var max = Collection.getMaxValue(domain);\n  var currentAxis = Helpers.getCurrentAxis(axis, props.horizontal);\n  var range = Helpers.getRange(props, currentAxis);\n  var rangeExtent = Math.abs(range[0] - range[1]); // Naive initial padding calculation\n\n  var initialPadding = {\n    left: Math.abs(max - min) * padding.left / rangeExtent,\n    right: Math.abs(max - min) * padding.right / rangeExtent\n  };\n  var singleQuadrantDomainPadding = _isPlainObject(props.singleQuadrantDomainPadding) ? props.singleQuadrantDomainPadding[axis] : props.singleQuadrantDomainPadding;\n\n  var adjust = function adjust(val, type) {\n    if (singleQuadrantDomainPadding === false) {\n      return val;\n    }\n\n    var coerce = type === \"min\" && min >= 0 && val <= 0 || type === \"max\" && max <= 0 && val >= 0;\n    return coerce ? 0 : val;\n  }; // Adjust the domain by the initial padding\n\n\n  var adjustedDomain = {\n    min: adjust(min.valueOf() - initialPadding.left, \"min\"),\n    max: adjust(max.valueOf() + initialPadding.right, \"max\")\n  }; // re-calculate padding, taking the adjusted domain into account\n\n  var finalPadding = {\n    left: Math.abs(adjustedDomain.max - adjustedDomain.min) * padding.left / rangeExtent,\n    right: Math.abs(adjustedDomain.max - adjustedDomain.min) * padding.right / rangeExtent\n  }; // Adjust the domain by the final padding\n\n  var paddedDomain = {\n    min: adjust(min.valueOf() - finalPadding.left, \"min\"),\n    max: adjust(max.valueOf() + finalPadding.right, \"max\")\n  }; // default to minDomain / maxDomain if they exist\n\n  var finalDomain = {\n    min: minDomain !== undefined ? minDomain : paddedDomain.min,\n    max: maxDomain !== undefined ? maxDomain : paddedDomain.max\n  };\n  return min instanceof Date || max instanceof Date ? getDomainFromMinMax(new Date(finalDomain.min), new Date(finalDomain.max)) : getDomainFromMinMax(finalDomain.min, finalDomain.max);\n} // Public Methods\n\n/**\n * Returns a getDomain function\n * @param {Function} getDomainFromDataFunction: a function that takes props and axis and\n * returns a domain based on data\n * @param {Function} formatDomainFunction: a function that takes domain, props, and axis and\n * returns a formatted domain\n * @returns {Function} a function that takes props and axis and returns a formatted domain\n */\n\n\nfunction createDomainFunction(getDomainFromDataFunction, formatDomainFunction) {\n  getDomainFromDataFunction = _isFunction(getDomainFromDataFunction) ? getDomainFromDataFunction : getDomainFromData;\n  formatDomainFunction = _isFunction(formatDomainFunction) ? formatDomainFunction : formatDomain;\n  return function (props, axis) {\n    var propsDomain = getDomainFromProps(props, axis);\n\n    if (propsDomain) {\n      return formatDomainFunction(propsDomain, props, axis);\n    }\n\n    var categories = Data.getCategories(props, axis);\n    var domain = categories ? getDomainFromCategories(props, axis, categories) : getDomainFromDataFunction(props, axis);\n    return domain ? formatDomainFunction(domain, props, axis) : undefined;\n  };\n}\n/**\n * Returns a formatted domain.\n * @param {Array} domain: a domain in the form of a two element array\n * @param {Object} props: the props object\n * @param {String} axis: the current axis\n * @returns {Array} a domain in the form of a two element array\n */\n\n\nfunction formatDomain(domain, props, axis) {\n  return cleanDomain(padDomain(domain, props, axis), props, axis);\n}\n/**\n * Returns a domain for a given axis based on props, category, or data\n * @param {Object} props: the props object\n * @param {String} axis: the current axis\n * @returns {Array} the domain for the given axis\n */\n\n\nfunction getDomain(props, axis) {\n  return createDomainFunction()(props, axis);\n}\n/**\n * Returns a domain based on categories if they exist\n * @param {Object} props: the props object\n * @param {String} axis: the current axis\n * @param {Array} categories: an array of categories corresponding to a given axis\n * @returns {Array|undefined} returns a domain from categories or undefined\n */\n\n\nfunction getDomainFromCategories(props, axis, categories) {\n  categories = categories || Data.getCategories(props, axis);\n  var polar = props.polar,\n      _props$startAngle = props.startAngle,\n      startAngle = _props$startAngle === void 0 ? 0 : _props$startAngle,\n      _props$endAngle = props.endAngle,\n      endAngle = _props$endAngle === void 0 ? 360 : _props$endAngle;\n\n  if (!categories) {\n    return undefined;\n  }\n\n  var minDomain = getMinFromProps(props, axis);\n  var maxDomain = getMaxFromProps(props, axis);\n  var stringArray = Collection.containsStrings(categories) ? Data.getStringsFromCategories(props, axis) : [];\n  var stringMap = stringArray.length === 0 ? null : stringArray.reduce(function (memo, string, index) {\n    memo[string] = index + 1;\n    return memo;\n  }, {});\n  var categoryValues = stringMap ? categories.map(function (value) {\n    return stringMap[value];\n  }) : categories;\n  var min = minDomain !== undefined ? minDomain : Collection.getMinValue(categoryValues);\n  var max = maxDomain !== undefined ? maxDomain : Collection.getMaxValue(categoryValues);\n  var categoryDomain = getDomainFromMinMax(min, max);\n  return polar && axis === \"x\" && Math.abs(startAngle - endAngle) === 360 ? getSymmetricDomain(categoryDomain, categoryValues) : categoryDomain;\n}\n/**\n * Returns a domain from a dataset for a given axis\n * @param {Object} props: the props object\n * @param {String} axis: the current axis\n * @param {Array} dataset: an array of data\n * @returns {Array} the domain based on data\n */\n\n\nfunction getDomainFromData(props, axis, dataset) {\n  dataset = dataset || Data.getData(props);\n  var polar = props.polar,\n      _props$startAngle2 = props.startAngle,\n      startAngle = _props$startAngle2 === void 0 ? 0 : _props$startAngle2,\n      _props$endAngle2 = props.endAngle,\n      endAngle = _props$endAngle2 === void 0 ? 360 : _props$endAngle2;\n  var minDomain = getMinFromProps(props, axis);\n  var maxDomain = getMaxFromProps(props, axis);\n\n  if (dataset.length < 1) {\n    return minDomain !== undefined && maxDomain !== undefined ? getDomainFromMinMax(minDomain, maxDomain) : undefined;\n  }\n\n  var min = minDomain !== undefined ? minDomain : getExtremeFromData(dataset, axis, \"min\");\n  var max = maxDomain !== undefined ? maxDomain : getExtremeFromData(dataset, axis, \"max\");\n  var domain = getDomainFromMinMax(min, max);\n  return polar && axis === \"x\" && Math.abs(startAngle - endAngle) === 360 ? getSymmetricDomain(domain, getFlatData(dataset, axis)) : domain;\n}\n/**\n * Returns a domain in the form of a two element array given a min and max value.\n * @param {Number|Date} min: the props object\n * @param {Number|Date} max: the current axis\n * @returns {Array} the minDomain based on props\n */\n\n\nfunction getDomainFromMinMax(min, max) {\n  var getSinglePointDomain = function getSinglePointDomain(val) {\n    // d3-scale does not properly resolve very small differences.\n    // eslint-disable-next-line no-magic-numbers\n    var verySmallNumber = val === 0 ? 2 * Math.pow(10, -10) : Math.pow(10, -10);\n    var verySmallDate = 1;\n    var minVal = val instanceof Date ? new Date(+val - verySmallDate) : +val - verySmallNumber;\n    var maxVal = val instanceof Date ? new Date(+val + verySmallDate) : +val + verySmallNumber;\n    return val === 0 ? [0, maxVal] : [minVal, maxVal];\n  };\n\n  return +min === +max ? getSinglePointDomain(max) : [min, max];\n}\n/**\n * Returns a the domain for a given axis if domain is given in props\n * @param {Object} props: the props object\n * @param {String} axis: the current axis\n * @returns {Array|undefined} the domain based on props\n */\n\n\nfunction getDomainFromProps(props, axis) {\n  var minDomain = getMinFromProps(props, axis);\n  var maxDomain = getMaxFromProps(props, axis);\n\n  if (_isPlainObject(props.domain) && props.domain[axis]) {\n    return props.domain[axis];\n  } else if (Array.isArray(props.domain)) {\n    return props.domain;\n  } else if (minDomain !== undefined && maxDomain !== undefined) {\n    return getDomainFromMinMax(minDomain, maxDomain);\n  }\n\n  return undefined;\n}\n/**\n * Returns a domain for a given axis. This method forces the domain to include\n * zero unless the domain is explicitly specified in props.\n * @param {Object} props: the props object\n * @param {String} axis: the current axis\n * @returns {Array} the domain for the given axis\n */\n\n\nfunction getDomainWithZero(props, axis) {\n  var propsDomain = getDomainFromProps(props, axis);\n\n  if (propsDomain) {\n    return propsDomain;\n  }\n\n  var dataset = Data.getData(props);\n  var y0Min = dataset.reduce(function (min, datum) {\n    return datum._y0 < min ? datum._y0 : min;\n  }, Infinity);\n\n  var ensureZero = function ensureZero(domain) {\n    if (axis === \"x\") {\n      return domain;\n    }\n\n    var defaultMin = y0Min !== Infinity ? y0Min : 0;\n    var maxDomainProp = getMaxFromProps(props, axis);\n    var minDomainProp = getMinFromProps(props, axis);\n    var max = maxDomainProp !== undefined ? maxDomainProp : Collection.getMaxValue(domain, defaultMin);\n    var min = minDomainProp !== undefined ? minDomainProp : Collection.getMinValue(domain, defaultMin);\n    return getDomainFromMinMax(min, max);\n  };\n\n  var getDomainFunction = function getDomainFunction() {\n    return getDomainFromData(props, axis, dataset);\n  };\n\n  var formatDomainFunction = function formatDomainFunction(domain) {\n    return formatDomain(ensureZero(domain), props, axis);\n  };\n\n  return createDomainFunction(getDomainFunction, formatDomainFunction)(props, axis);\n}\n/**\n * Returns the maxDomain from props if it exists\n * @param {Object} props: the props object\n * @param {String} axis: the current axis\n * @returns {Number|undefined} the maxDomain based on props\n */\n\n\nfunction getMaxFromProps(props, axis) {\n  if (_isPlainObject(props.maxDomain) && props.maxDomain[axis] !== undefined) {\n    return props.maxDomain[axis];\n  }\n\n  return typeof props.maxDomain === \"number\" ? props.maxDomain : undefined;\n}\n/**\n * Returns the minDomain from props if it exists\n * @param {Object} props: the props object\n * @param {String} axis: the current axis\n * @returns {Number|undefined} the minDomain based on props\n */\n\n\nfunction getMinFromProps(props, axis) {\n  if (_isPlainObject(props.minDomain) && props.minDomain[axis] !== undefined) {\n    return props.minDomain[axis];\n  }\n\n  return typeof props.minDomain === \"number\" ? props.minDomain : undefined;\n}\n/**\n * Returns a symmetrically padded domain for polar charts\n * @param {Array} domain: the original domain\n * @param {Array} values: a flat array of values corresponding to either tickValues, or data values\n * for a given dimension i.e. only x values.\n * @returns {Array} the symmetric domain\n */\n\n\nfunction getSymmetricDomain(domain, values) {\n  var processedData = _sortedUniq(values.sort(function (a, b) {\n    return a - b;\n  }));\n\n  var step = processedData[1] - processedData[0];\n  return [domain[0], domain[1] + step];\n}\n/**\n * Checks whether a given component can be used to calculate domain\n * @param {Component} component: a React component instance\n * @returns {Boolean} Returns true if the given component has a role included in the whitelist\n */\n\n\nfunction isDomainComponent(component) {\n  var getRole = function getRole(child) {\n    return child && child.type ? child.type.role : \"\";\n  };\n\n  var role = getRole(component);\n\n  if (role === \"portal\") {\n    var children = React.Children.toArray(component.props.children);\n    role = children.length ? getRole(children[0]) : \"\";\n  }\n\n  var whitelist = [\"area\", \"axis\", \"bar\", \"boxplot\", \"candlestick\", \"errorbar\", \"group\", \"line\", \"pie\", \"scatter\", \"stack\", \"voronoi\"];\n  return _includes(whitelist, role);\n}\n\nexport default {\n  createDomainFunction: createDomainFunction,\n  formatDomain: formatDomain,\n  getDomain: getDomain,\n  getDomainFromCategories: getDomainFromCategories,\n  getDomainFromData: getDomainFromData,\n  getDomainFromMinMax: getDomainFromMinMax,\n  getDomainFromProps: getDomainFromProps,\n  getDomainWithZero: getDomainWithZero,\n  getMaxFromProps: getMaxFromProps,\n  getMinFromProps: getMinFromProps,\n  getSymmetricDomain: getSymmetricDomain,\n  isDomainComponent: isDomainComponent\n};","map":{"version":3,"sources":["/Users/abdurauf/Desktop/毕业设计/orginal/restaurant-management-system/plov/node_modules/victory-core/es/victory-util/domain.js"],"names":["_includes","_isFunction","_sortedUniq","_isPlainObject","_flatten","_toConsumableArray","arr","_arrayWithoutHoles","_iterableToArray","_nonIterableSpread","TypeError","iter","Symbol","iterator","Object","prototype","toString","call","Array","from","isArray","i","arr2","length","React","Data","Scale","Helpers","Collection","cleanDomain","domain","props","axis","scaleType","getScaleType","rules","dom","almostZero","Number","MAX_SAFE_INTEGER","domainOne","domainTwo","getDomainPadding","formatPadding","padding","left","right","domainPadding","getFlatData","dataset","map","datum","concat","undefined","getExtremeFromData","type","arguments","getExtreme","Math","max","apply","min","initialValue","Infinity","containsDate","result","reduce","memo","current0","current1","current","Date","padDomain","minDomain","getMinFromProps","maxDomain","getMaxFromProps","getMinValue","getMaxValue","currentAxis","getCurrentAxis","horizontal","range","getRange","rangeExtent","abs","initialPadding","singleQuadrantDomainPadding","adjust","val","coerce","adjustedDomain","valueOf","finalPadding","paddedDomain","finalDomain","getDomainFromMinMax","createDomainFunction","getDomainFromDataFunction","formatDomainFunction","getDomainFromData","formatDomain","propsDomain","getDomainFromProps","categories","getCategories","getDomainFromCategories","getDomain","polar","_props$startAngle","startAngle","_props$endAngle","endAngle","stringArray","containsStrings","getStringsFromCategories","stringMap","string","index","categoryValues","value","categoryDomain","getSymmetricDomain","getData","_props$startAngle2","_props$endAngle2","getSinglePointDomain","verySmallNumber","pow","verySmallDate","minVal","maxVal","getDomainWithZero","y0Min","_y0","ensureZero","defaultMin","maxDomainProp","minDomainProp","getDomainFunction","values","processedData","sort","a","b","step","isDomainComponent","component","getRole","child","role","children","Children","toArray","whitelist"],"mappings":"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","sourcesContent":["import _includes from \"lodash/includes\";\nimport _isFunction from \"lodash/isFunction\";\nimport _sortedUniq from \"lodash/sortedUniq\";\nimport _isPlainObject from \"lodash/isPlainObject\";\nimport _flatten from \"lodash/flatten\";\n\nfunction _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _nonIterableSpread(); }\n\nfunction _nonIterableSpread() { throw new TypeError(\"Invalid attempt to spread non-iterable instance\"); }\n\nfunction _iterableToArray(iter) { if (Symbol.iterator in Object(iter) || Object.prototype.toString.call(iter) === \"[object Arguments]\") return Array.from(iter); }\n\nfunction _arrayWithoutHoles(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = new Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } }\n\n/* eslint-disable func-style */\n\n/* eslint-disable no-use-before-define */\nimport React from \"react\";\nimport Data from \"./data\";\nimport Scale from \"./scale\";\nimport Helpers from \"./helpers\";\nimport Collection from \"./collection\"; // Private Methods\n\nfunction cleanDomain(domain, props, axis) {\n  var scaleType = Scale.getScaleType(props, axis);\n\n  if (scaleType !== \"log\") {\n    return domain;\n  }\n\n  var rules = function (dom) {\n    var almostZero = dom[0] < 0 || dom[1] < 0 ? -1 / Number.MAX_SAFE_INTEGER : 1 / Number.MAX_SAFE_INTEGER;\n    var domainOne = dom[0] === 0 ? almostZero : dom[0];\n    var domainTwo = dom[1] === 0 ? almostZero : dom[1];\n    return [domainOne, domainTwo];\n  };\n\n  return rules(domain);\n}\n\nfunction getDomainPadding(props, axis) {\n  var formatPadding = function (padding) {\n    return Array.isArray(padding) ? {\n      left: padding[0],\n      right: padding[1]\n    } : {\n      left: padding,\n      right: padding\n    };\n  };\n\n  return _isPlainObject(props.domainPadding) ? formatPadding(props.domainPadding[axis]) : formatPadding(props.domainPadding);\n}\n\nfunction getFlatData(dataset, axis) {\n  return _flatten(dataset).map(function (datum) {\n    return datum[\"_\".concat(axis)] && datum[\"_\".concat(axis)][1] !== undefined ? datum[\"_\".concat(axis)][1] : datum[\"_\".concat(axis)];\n  });\n}\n\nfunction getExtremeFromData(dataset, axis) {\n  var type = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : \"min\";\n\n  var getExtreme = function (arr) {\n    return type === \"max\" ? Math.max.apply(Math, _toConsumableArray(arr)) : Math.min.apply(Math, _toConsumableArray(arr));\n  };\n\n  var initialValue = type === \"max\" ? -Infinity : Infinity;\n  var containsDate = false;\n\n  var result = _flatten(dataset).reduce(function (memo, datum) {\n    var current0 = datum[\"_\".concat(axis, \"0\")] !== undefined ? datum[\"_\".concat(axis, \"0\")] : datum[\"_\".concat(axis)];\n    var current1 = datum[\"_\".concat(axis, \"1\")] !== undefined ? datum[\"_\".concat(axis, \"1\")] : datum[\"_\".concat(axis)];\n    var current = getExtreme([current0, current1]);\n    containsDate = containsDate || current0 instanceof Date || current1 instanceof Date;\n    return getExtreme([memo, current]);\n  }, initialValue);\n\n  return containsDate ? new Date(result) : result;\n} //eslint-disable-next-line max-statements\n\n\nfunction padDomain(domain, props, axis) {\n  if (!props.domainPadding) {\n    return domain;\n  }\n\n  var minDomain = getMinFromProps(props, axis);\n  var maxDomain = getMaxFromProps(props, axis);\n  var padding = getDomainPadding(props, axis);\n\n  if (!padding.left && !padding.right) {\n    return domain;\n  }\n\n  var min = Collection.getMinValue(domain);\n  var max = Collection.getMaxValue(domain);\n  var currentAxis = Helpers.getCurrentAxis(axis, props.horizontal);\n  var range = Helpers.getRange(props, currentAxis);\n  var rangeExtent = Math.abs(range[0] - range[1]); // Naive initial padding calculation\n\n  var initialPadding = {\n    left: Math.abs(max - min) * padding.left / rangeExtent,\n    right: Math.abs(max - min) * padding.right / rangeExtent\n  };\n  var singleQuadrantDomainPadding = _isPlainObject(props.singleQuadrantDomainPadding) ? props.singleQuadrantDomainPadding[axis] : props.singleQuadrantDomainPadding;\n\n  var adjust = function (val, type) {\n    if (singleQuadrantDomainPadding === false) {\n      return val;\n    }\n\n    var coerce = type === \"min\" && min >= 0 && val <= 0 || type === \"max\" && max <= 0 && val >= 0;\n    return coerce ? 0 : val;\n  }; // Adjust the domain by the initial padding\n\n\n  var adjustedDomain = {\n    min: adjust(min.valueOf() - initialPadding.left, \"min\"),\n    max: adjust(max.valueOf() + initialPadding.right, \"max\")\n  }; // re-calculate padding, taking the adjusted domain into account\n\n  var finalPadding = {\n    left: Math.abs(adjustedDomain.max - adjustedDomain.min) * padding.left / rangeExtent,\n    right: Math.abs(adjustedDomain.max - adjustedDomain.min) * padding.right / rangeExtent\n  }; // Adjust the domain by the final padding\n\n  var paddedDomain = {\n    min: adjust(min.valueOf() - finalPadding.left, \"min\"),\n    max: adjust(max.valueOf() + finalPadding.right, \"max\")\n  }; // default to minDomain / maxDomain if they exist\n\n  var finalDomain = {\n    min: minDomain !== undefined ? minDomain : paddedDomain.min,\n    max: maxDomain !== undefined ? maxDomain : paddedDomain.max\n  };\n  return min instanceof Date || max instanceof Date ? getDomainFromMinMax(new Date(finalDomain.min), new Date(finalDomain.max)) : getDomainFromMinMax(finalDomain.min, finalDomain.max);\n} // Public Methods\n\n/**\n * Returns a getDomain function\n * @param {Function} getDomainFromDataFunction: a function that takes props and axis and\n * returns a domain based on data\n * @param {Function} formatDomainFunction: a function that takes domain, props, and axis and\n * returns a formatted domain\n * @returns {Function} a function that takes props and axis and returns a formatted domain\n */\n\n\nfunction createDomainFunction(getDomainFromDataFunction, formatDomainFunction) {\n  getDomainFromDataFunction = _isFunction(getDomainFromDataFunction) ? getDomainFromDataFunction : getDomainFromData;\n  formatDomainFunction = _isFunction(formatDomainFunction) ? formatDomainFunction : formatDomain;\n  return function (props, axis) {\n    var propsDomain = getDomainFromProps(props, axis);\n\n    if (propsDomain) {\n      return formatDomainFunction(propsDomain, props, axis);\n    }\n\n    var categories = Data.getCategories(props, axis);\n    var domain = categories ? getDomainFromCategories(props, axis, categories) : getDomainFromDataFunction(props, axis);\n    return domain ? formatDomainFunction(domain, props, axis) : undefined;\n  };\n}\n/**\n * Returns a formatted domain.\n * @param {Array} domain: a domain in the form of a two element array\n * @param {Object} props: the props object\n * @param {String} axis: the current axis\n * @returns {Array} a domain in the form of a two element array\n */\n\n\nfunction formatDomain(domain, props, axis) {\n  return cleanDomain(padDomain(domain, props, axis), props, axis);\n}\n/**\n * Returns a domain for a given axis based on props, category, or data\n * @param {Object} props: the props object\n * @param {String} axis: the current axis\n * @returns {Array} the domain for the given axis\n */\n\n\nfunction getDomain(props, axis) {\n  return createDomainFunction()(props, axis);\n}\n/**\n * Returns a domain based on categories if they exist\n * @param {Object} props: the props object\n * @param {String} axis: the current axis\n * @param {Array} categories: an array of categories corresponding to a given axis\n * @returns {Array|undefined} returns a domain from categories or undefined\n */\n\n\nfunction getDomainFromCategories(props, axis, categories) {\n  categories = categories || Data.getCategories(props, axis);\n  var polar = props.polar,\n      _props$startAngle = props.startAngle,\n      startAngle = _props$startAngle === void 0 ? 0 : _props$startAngle,\n      _props$endAngle = props.endAngle,\n      endAngle = _props$endAngle === void 0 ? 360 : _props$endAngle;\n\n  if (!categories) {\n    return undefined;\n  }\n\n  var minDomain = getMinFromProps(props, axis);\n  var maxDomain = getMaxFromProps(props, axis);\n  var stringArray = Collection.containsStrings(categories) ? Data.getStringsFromCategories(props, axis) : [];\n  var stringMap = stringArray.length === 0 ? null : stringArray.reduce(function (memo, string, index) {\n    memo[string] = index + 1;\n    return memo;\n  }, {});\n  var categoryValues = stringMap ? categories.map(function (value) {\n    return stringMap[value];\n  }) : categories;\n  var min = minDomain !== undefined ? minDomain : Collection.getMinValue(categoryValues);\n  var max = maxDomain !== undefined ? maxDomain : Collection.getMaxValue(categoryValues);\n  var categoryDomain = getDomainFromMinMax(min, max);\n  return polar && axis === \"x\" && Math.abs(startAngle - endAngle) === 360 ? getSymmetricDomain(categoryDomain, categoryValues) : categoryDomain;\n}\n/**\n * Returns a domain from a dataset for a given axis\n * @param {Object} props: the props object\n * @param {String} axis: the current axis\n * @param {Array} dataset: an array of data\n * @returns {Array} the domain based on data\n */\n\n\nfunction getDomainFromData(props, axis, dataset) {\n  dataset = dataset || Data.getData(props);\n  var polar = props.polar,\n      _props$startAngle2 = props.startAngle,\n      startAngle = _props$startAngle2 === void 0 ? 0 : _props$startAngle2,\n      _props$endAngle2 = props.endAngle,\n      endAngle = _props$endAngle2 === void 0 ? 360 : _props$endAngle2;\n  var minDomain = getMinFromProps(props, axis);\n  var maxDomain = getMaxFromProps(props, axis);\n\n  if (dataset.length < 1) {\n    return minDomain !== undefined && maxDomain !== undefined ? getDomainFromMinMax(minDomain, maxDomain) : undefined;\n  }\n\n  var min = minDomain !== undefined ? minDomain : getExtremeFromData(dataset, axis, \"min\");\n  var max = maxDomain !== undefined ? maxDomain : getExtremeFromData(dataset, axis, \"max\");\n  var domain = getDomainFromMinMax(min, max);\n  return polar && axis === \"x\" && Math.abs(startAngle - endAngle) === 360 ? getSymmetricDomain(domain, getFlatData(dataset, axis)) : domain;\n}\n/**\n * Returns a domain in the form of a two element array given a min and max value.\n * @param {Number|Date} min: the props object\n * @param {Number|Date} max: the current axis\n * @returns {Array} the minDomain based on props\n */\n\n\nfunction getDomainFromMinMax(min, max) {\n  var getSinglePointDomain = function (val) {\n    // d3-scale does not properly resolve very small differences.\n    // eslint-disable-next-line no-magic-numbers\n    var verySmallNumber = val === 0 ? 2 * Math.pow(10, -10) : Math.pow(10, -10);\n    var verySmallDate = 1;\n    var minVal = val instanceof Date ? new Date(+val - verySmallDate) : +val - verySmallNumber;\n    var maxVal = val instanceof Date ? new Date(+val + verySmallDate) : +val + verySmallNumber;\n    return val === 0 ? [0, maxVal] : [minVal, maxVal];\n  };\n\n  return +min === +max ? getSinglePointDomain(max) : [min, max];\n}\n/**\n * Returns a the domain for a given axis if domain is given in props\n * @param {Object} props: the props object\n * @param {String} axis: the current axis\n * @returns {Array|undefined} the domain based on props\n */\n\n\nfunction getDomainFromProps(props, axis) {\n  var minDomain = getMinFromProps(props, axis);\n  var maxDomain = getMaxFromProps(props, axis);\n\n  if (_isPlainObject(props.domain) && props.domain[axis]) {\n    return props.domain[axis];\n  } else if (Array.isArray(props.domain)) {\n    return props.domain;\n  } else if (minDomain !== undefined && maxDomain !== undefined) {\n    return getDomainFromMinMax(minDomain, maxDomain);\n  }\n\n  return undefined;\n}\n/**\n * Returns a domain for a given axis. This method forces the domain to include\n * zero unless the domain is explicitly specified in props.\n * @param {Object} props: the props object\n * @param {String} axis: the current axis\n * @returns {Array} the domain for the given axis\n */\n\n\nfunction getDomainWithZero(props, axis) {\n  var propsDomain = getDomainFromProps(props, axis);\n\n  if (propsDomain) {\n    return propsDomain;\n  }\n\n  var dataset = Data.getData(props);\n  var y0Min = dataset.reduce(function (min, datum) {\n    return datum._y0 < min ? datum._y0 : min;\n  }, Infinity);\n\n  var ensureZero = function (domain) {\n    if (axis === \"x\") {\n      return domain;\n    }\n\n    var defaultMin = y0Min !== Infinity ? y0Min : 0;\n    var maxDomainProp = getMaxFromProps(props, axis);\n    var minDomainProp = getMinFromProps(props, axis);\n    var max = maxDomainProp !== undefined ? maxDomainProp : Collection.getMaxValue(domain, defaultMin);\n    var min = minDomainProp !== undefined ? minDomainProp : Collection.getMinValue(domain, defaultMin);\n    return getDomainFromMinMax(min, max);\n  };\n\n  var getDomainFunction = function () {\n    return getDomainFromData(props, axis, dataset);\n  };\n\n  var formatDomainFunction = function (domain) {\n    return formatDomain(ensureZero(domain), props, axis);\n  };\n\n  return createDomainFunction(getDomainFunction, formatDomainFunction)(props, axis);\n}\n/**\n * Returns the maxDomain from props if it exists\n * @param {Object} props: the props object\n * @param {String} axis: the current axis\n * @returns {Number|undefined} the maxDomain based on props\n */\n\n\nfunction getMaxFromProps(props, axis) {\n  if (_isPlainObject(props.maxDomain) && props.maxDomain[axis] !== undefined) {\n    return props.maxDomain[axis];\n  }\n\n  return typeof props.maxDomain === \"number\" ? props.maxDomain : undefined;\n}\n/**\n * Returns the minDomain from props if it exists\n * @param {Object} props: the props object\n * @param {String} axis: the current axis\n * @returns {Number|undefined} the minDomain based on props\n */\n\n\nfunction getMinFromProps(props, axis) {\n  if (_isPlainObject(props.minDomain) && props.minDomain[axis] !== undefined) {\n    return props.minDomain[axis];\n  }\n\n  return typeof props.minDomain === \"number\" ? props.minDomain : undefined;\n}\n/**\n * Returns a symmetrically padded domain for polar charts\n * @param {Array} domain: the original domain\n * @param {Array} values: a flat array of values corresponding to either tickValues, or data values\n * for a given dimension i.e. only x values.\n * @returns {Array} the symmetric domain\n */\n\n\nfunction getSymmetricDomain(domain, values) {\n  var processedData = _sortedUniq(values.sort(function (a, b) {\n    return a - b;\n  }));\n\n  var step = processedData[1] - processedData[0];\n  return [domain[0], domain[1] + step];\n}\n/**\n * Checks whether a given component can be used to calculate domain\n * @param {Component} component: a React component instance\n * @returns {Boolean} Returns true if the given component has a role included in the whitelist\n */\n\n\nfunction isDomainComponent(component) {\n  var getRole = function (child) {\n    return child && child.type ? child.type.role : \"\";\n  };\n\n  var role = getRole(component);\n\n  if (role === \"portal\") {\n    var children = React.Children.toArray(component.props.children);\n    role = children.length ? getRole(children[0]) : \"\";\n  }\n\n  var whitelist = [\"area\", \"axis\", \"bar\", \"boxplot\", \"candlestick\", \"errorbar\", \"group\", \"line\", \"pie\", \"scatter\", \"stack\", \"voronoi\"];\n  return _includes(whitelist, role);\n}\n\nexport default {\n  createDomainFunction: createDomainFunction,\n  formatDomain: formatDomain,\n  getDomain: getDomain,\n  getDomainFromCategories: getDomainFromCategories,\n  getDomainFromData: getDomainFromData,\n  getDomainFromMinMax: getDomainFromMinMax,\n  getDomainFromProps: getDomainFromProps,\n  getDomainWithZero: getDomainWithZero,\n  getMaxFromProps: getMaxFromProps,\n  getMinFromProps: getMinFromProps,\n  getSymmetricDomain: getSymmetricDomain,\n  isDomainComponent: isDomainComponent\n};"]},"metadata":{},"sourceType":"module"}